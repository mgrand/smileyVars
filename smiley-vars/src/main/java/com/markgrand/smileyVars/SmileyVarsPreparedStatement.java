package com.markgrand.smileyVars;

import com.markgrand.smileyVars.util.BiSqlConsumer;
import com.markgrand.smileyVars.util.QuadSqlConsumer;
import com.markgrand.smileyVars.util.TriSqlConsumer;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.InputStream;
import java.io.Reader;
import java.math.BigDecimal;
import java.net.URL;
import java.sql.Date;
import java.sql.*;
import java.util.*;

/**
 * SmileyVars enabled version of a prepared statement.
 *
 * <p>This class uses {@link PreparedStatement} objects to implement database interactions. To the extent practical,
 * it attempts to reuse the same {@code PreparedStatement} object for operations.</p>
 *
 * <p>If two operations are done with exactly the same SmileyVars having values (it can be different values from one
 * operation to the next), then they will use the same {@code PreparedStatement} object. When different combinations of
 * SmileyVars have values then different {@code PreparedStatement} objects will be used.</p>
 *
 * <p>The underlying {@code PreparedStatement} objects are closed when this object's close method is called. It is a
 * recommended good practice to always close {@code SmileyVarsPreparedStatement} objects.</p>
 *
 * @author Mark Grand
 */
public class SmileyVarsPreparedStatement implements AutoCloseable {
    private static final Logger logger = LoggerFactory.getLogger(SmileyVarsPreparedStatement.class);

    private final Connection connection;
    private final SmileyVarsTemplate template;

    /**
     * Map SmileyVar names to parameter values. A null value means no value has been provided for the named SmileyVar.
     * If a null value is provided for a SmileyVar, a {@link NullValue} object is used to represent the null value.
     */
    private final LinkedHashMap<String, Object> valueMap = new LinkedHashMap<>();

    /**
     * PreparedStatement objects are collected in this map so they can be reused. The goal of the reuse is to use the
     * same PreparedStatement object for operations that are done with the same SmileyVars having values.
     */
    private final Map<BitSet, PreparedStatementTag> taggedPstmtMap = new HashMap<>();

    private boolean closed = false;
    private long changeCount = 0;

    /**
     * Constructor
     *
     * @param conn the connection to use for interacting with the database.
     * @param sql  the SQL of the template.
     * @throws SQLException if there is a problem with the connection.
     */
    public SmileyVarsPreparedStatement(@NotNull Connection conn, @NotNull String sql) throws SQLException {
        logger.trace("Constructing SmileyVars prepared statement for {}", sql);
        connection = conn;
        template = SmileyVarsTemplate.template(conn, sql);
        template.getVarNames().forEach(name -> valueMap.put(name, null));
    }

    /**
     * Executes the SQL query in this <code>PreparedStatement</code> object and returns the <code>ResultSet</code>
     * object generated by the query.
     *
     * @return a <code>ResultSet</code> object that contains the data produced by the query; never <code>null</code>
     * @throws SQLException        if a database access error occurs; this method is called on a closed
     *                             <code>PreparedStatement</code> or the SQL statement does not return a
     *                             <code>ResultSet</code> object
     * @throws SQLTimeoutException when the driver has determined that the timeout value that was specified by the
     *                             {@code setQueryTimeout} method has been exceeded and has at least attempted to cancel
     *                             the currently running {@code Statement}
     */
    public ResultSet executeQuery() throws SQLException {
        return getPreparedStatement().executeQuery();
    }

    /**
     * Executes the SQL statement in this <code>PreparedStatement</code> object, which must be an SQL Data Manipulation
     * Language (DML) statement, such as <code>INSERT</code>, <code>UPDATE</code> or
     * <code>DELETE</code>; or an SQL statement that returns nothing,
     * such as a DDL statement.
     *
     * @return either (1) the row count for SQL Data Manipulation Language (DML) statements or (2) 0 for SQL statements
     * that return nothing
     * @throws SQLException        if a database access error occurs; this method is called on a closed
     *                             <code>PreparedStatement</code> or the SQL statement returns a <code>ResultSet</code>
     *                             object
     * @throws SQLTimeoutException when the driver has determined that the timeout value that was specified by the
     *                             {@code setQueryTimeout} method has been exceeded and has at least attempted to cancel
     *                             the currently running {@code Statement}
     */
    public int executeUpdate() throws SQLException {
        return getPreparedStatement().executeUpdate();
    }

    /**
     * Sets the designated parameter to SQL <code>NULL</code>.
     *
     * <P><B>Note:</B> You must specify the parameter's SQL type.
     *
     * @param parameterName The name of the parameter.
     * @param sqlType       The SQL type code defined in <code>java.sql.Types</code>
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setNull(String parameterName, int sqlType) throws SQLException {
        changeWithCheckedName(parameterName, sqlType, (name, type) -> valueMap.put(name, new NullValue(type)));
        if (valueMap.containsKey(parameterName)) {
            valueMap.put(parameterName, new NullValue(sqlType));
            changeCount++;
        } else {
            throwForUnknownParameter(parameterName);
        }
    }

    /**
     * Sets the designated parameter to the given Java <code>boolean</code> value.
     *
     * @param parameterName The name of the parameter.
     * @param value         the parameter value
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setBoolean(String parameterName, boolean value) throws SQLException {
        changeWithCheckedName(parameterName, value, (name, val) -> valueMap.put(name, new BooleanValue(val)));
    }

    /**
     * Sets the designated parameter to the given Java <code>byte</code> value. The driver converts this to an SQL
     * <code>TINYINT</code> value when it sends it to the database.
     *
     * @param parameterName The name of the parameter.
     * @param value         the parameter value
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setByte(String parameterName, byte value) throws SQLException {
        changeWithCheckedName(parameterName, value, (name, val) -> valueMap.put(name, new ByteValue(val)));
    }

    /**
     * Sets the designated parameter to the given Java <code>short</code> value. The driver converts this to an SQL
     * <code>SMALLINT</code> value when it sends it to the database.
     *
     * @param parameterName The name of the parameter.
     * @param value         the parameter value
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setShort(String parameterName, short value) throws SQLException {
        changeWithCheckedName(parameterName, value, (name, val) -> valueMap.put(name, new ShortValue(val)));
    }

    /**
     * Sets the designated parameter to the given Java <code>int</code> value. The driver converts this to an SQL
     * <code>INTEGER</code> value when it sends it to the database.
     *
     * @param parameterName The name of the parameter.
     * @param value         the parameter value
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setInt(String parameterName, int value) throws SQLException {
        changeWithCheckedName(parameterName, value, (name, val) -> valueMap.put(name, new IntValue(val)));
    }

    /**
     * Sets the designated parameter to the given Java <code>long</code> value. The driver converts this to an SQL
     * <code>BIGINT</code> value when it sends it to the database.
     *
     * @param parameterName The name of the parameter.
     * @param value         the parameter value
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setLong(String parameterName, long value) throws SQLException {
        changeWithCheckedName(parameterName, value, (name, val) -> valueMap.put(name, new LongValue(val)));
    }

    /**
     * Sets the designated parameter to the given Java <code>float</code> value. The driver converts this to an SQL
     * <code>REAL</code> value when it sends it to the database.
     *
     * @param parameterName The name of the parameter.
     * @param value         the parameter value
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setFloat(String parameterName, float value) throws SQLException {
        changeWithCheckedName(parameterName, value, (name, val) -> valueMap.put(name, new FloatValue(val)));
    }

    /**
     * Sets the designated parameter to the given Java <code>double</code> value. The driver converts this to an SQL
     * <code>DOUBLE</code> value when it sends it to the database.
     *
     * @param parameterName The name of the parameter.
     * @param value         the parameter value
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setDouble(String parameterName, double value) throws SQLException {
        changeWithCheckedName(parameterName, value, (name, val) -> valueMap.put(name, new DoubleValue(val)));
    }

    /**
     * Sets the designated parameter to the given <code>java.math.BigDecimal</code> value. The driver converts this to
     * an SQL <code>NUMERIC</code> value when it sends it to the database.
     *
     * @param parameterName The name of the parameter.
     * @param value         the parameter value
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setBigDecimal(String parameterName, BigDecimal value) throws SQLException {
        changeWithCheckedName(parameterName, value, (name, val) -> valueMap.put(name, new BigDecimalValue(val)));
    }

    /**
     * Sets the designated parameter to the given Java <code>String</code> value. The driver converts this to an SQL
     * <code>VARCHAR</code> or <code>LONGVARCHAR</code> value (depending on the argument's size relative to the
     * driver's limits on <code>VARCHAR</code> values) when it sends it to the database.
     *
     * @param parameterName The name of the parameter.
     * @param value         the parameter value
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setString(String parameterName, String value) throws SQLException {
        changeWithCheckedName(parameterName, value, (name, val) -> valueMap.put(name, new StringValue(val)));
    }

    /**
     * Sets the designated parameter to the given Java array of bytes.  The driver converts this to an SQL
     * <code>VARBINARY</code> or <code>LONGVARBINARY</code> (depending on the argument's size relative to the driver's
     * limits on
     * <code>VARBINARY</code> values) when it sends it to the database.
     *
     * @param parameterName The name of the parameter.
     * @param value         the parameter value
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setBytes(String parameterName, byte[] value) throws SQLException {
        changeWithCheckedName(parameterName, value, (name, val) -> valueMap.put(name, new ByteArrayValue(val)));
    }

    /**
     * Sets the designated parameter to the given <code>java.sql.Date</code> value using the default time zone of the
     * virtual machine that is running the application. The driver converts this to an SQL <code>DATE</code> value when
     * it sends it to the database.
     *
     * @param parameterName The name of the parameter.
     * @param value         the parameter value
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setDate(String parameterName, Date value) throws SQLException {
        changeWithCheckedName(parameterName, value, (name, val) -> valueMap.put(name, new DateValue(val)));
    }

    /**
     * Sets the designated parameter to the given <code>java.sql.Time</code> value. The driver converts this to an SQL
     * <code>TIME</code> value when it sends it to the database.
     *
     * @param parameterName The name of the parameter.
     * @param value         the parameter value
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setTime(String parameterName, Time value) throws SQLException {
        changeWithCheckedName(parameterName, value, (name, val) -> valueMap.put(name, new TimeValue(val)));
    }

    /**
     * Sets the designated parameter to the given <code>java.sql.Timestamp</code> value. The driver converts this to an
     * SQL <code>TIMESTAMP</code> value when it sends it to the database.
     *
     * @param parameterName The name of the parameter.
     * @param value         the parameter value
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setTimestamp(String parameterName, Timestamp value) throws SQLException {
        changeWithCheckedName(parameterName, value, (name, val) -> valueMap.put(name, new TimestampValue(val)));
    }

    /**
     * Sets the designated parameter to the given input stream, which will have the specified number of bytes. When a
     * very large ASCII value is input to a <code>LONGVARCHAR</code> parameter, it may be more practical to send it via
     * a
     * <code>java.io.InputStream</code>. Data will be read from the stream
     * as needed until end-of-file is reached.  The JDBC driver will do any necessary conversion from ASCII to the
     * database char format.
     *
     * <P><B>Note:</B> This stream object can either be a standard
     * Java stream object or your own subclass that implements the standard interface.
     *
     * @param parameterName The name of the parameter.
     * @param inputStream   the Java input stream that contains the ASCII parameter value
     * @param length        the number of bytes in the stream
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setAsciiStream(String parameterName, InputStream inputStream, int length) throws SQLException {
        changeWithCheckedName(parameterName, inputStream, length, (name, in, len) -> valueMap.put(name, new AsciiStreamValue(in, len)));
    }

    /**
     * Sets the designated parameter to the given input stream, which will have the specified number of bytes. When a
     * very large binary value is input to a <code>LONGVARBINARY</code> parameter, it may be more practical to send it
     * via a
     * <code>java.io.InputStream</code> object. The data will be read from the
     * stream as needed until end-of-file is reached.
     *
     * <P><B>Note:</B> This stream object can either be a standard
     * Java stream object or your own subclass that implements the standard interface.
     *
     * @param parameterName The name of the parameter.
     * @param inputStream   the Java input stream that contains the binary parameter value
     * @param length        the number of bytes in the stream
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setBinaryStream(String parameterName, InputStream inputStream, int length) throws SQLException {
        changeWithCheckedName(parameterName, inputStream, length, (name, in, len) -> valueMap.put(name, new BinaryStreamValue(in, len)));
    }

    /**
     * Sets the value of the designated parameter with the given object.
     * <p>
     * This method is similar to {@link #setObject(String parameterName, Object object, int targetSqlType, int
     * scaleOrLength)}, except that it assumes a scale of zero.
     *
     * @param parameterName The name of the parameter.
     * @param obj           the object containing the Object parameter value
     * @param targetSqlType the SQL type (as defined in java.sql.Types) to be sent to the database
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     * @see Types
     */
    public void setObject(String parameterName, Object obj, int targetSqlType) throws SQLException {
        changeWithCheckedName(parameterName, obj, targetSqlType, (name, o, type) -> valueMap.put(name, new ObjectValue(o, type)));
    }

    /**
     * <p>Sets the value of the designated parameter using the given object.
     *
     * <p>The JDBC specification specifies a standard mapping from Java <code>Object</code> types to SQL types.  The
     * given argument will be converted to the corresponding SQL type before being sent to the database.
     *
     * <p>
     * If the object is of a class implementing the interface <code>SQLData</code>, the JDBC driver should call the
     * method <code>SQLData.writeSQL</code> to write it to the SQL data stream. If, on the other hand, the object is of
     * a class implementing <code>Ref</code>, <code>Blob</code>, <code>Clob</code>,  <code>NClob</code>,
     * <code>Struct</code>, <code>java.net.URL</code>, <code>RowId</code>, <code>SQLXML</code> or <code>Array</code>,
     * the driver should pass it to the database as a value of the corresponding SQL type.
     * <p>
     * <b>Note:</b> Not all databases allow for a non-typed Null to be sent to
     * the backend. For maximum portability, the <code>setNull</code> or the
     * <code>setObject(int parameterIndex, Object x, int sqlType)</code>
     * method should be used instead of <code>setObject(int parameterIndex, Object x)</code>.
     *
     * @param parameterName The name of the parameter.
     * @param obj           the object containing the Object parameter value
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setObject(String parameterName, Object obj) throws SQLException {
        changeWithCheckedName(parameterName, obj, (name, o) -> valueMap.put(name, new ObjectValue(o)));
    }

    /**
     * Executes the SQL statement in this <code>PreparedStatement</code> object, which may be any kind of SQL statement.
     * Some prepared statements return multiple results; the <code>execute</code> method handles these complex
     * statements as well as the simpler form of statements handled by the methods <code>executeQuery</code> and
     * <code>executeUpdate</code>.
     * <p>
     * The <code>execute</code> method returns a <code>boolean</code> to indicate the form of the first result.  You
     * must call either the method
     * <code>getResultSet</code> or <code>getUpdateCount</code>
     * to retrieve the result; you must call <code>getMoreResults</code> to move to any subsequent result(s).
     *
     * @return <code>true</code> if the first result is a <code>ResultSet</code>
     * object; <code>false</code> if the first result is an update count or there is no result
     * @throws SQLException        if a database access error occurs; this method is called on a closed
     *                             <code>PreparedStatement</code> or an argument is supplied to this method
     * @throws SQLTimeoutException when the driver has determined that the timeout value that was specified by the
     *                             {@code setQueryTimeout} method has been exceeded and has at least attempted to cancel
     *                             the currently running {@code Statement}
     * @see Statement#execute
     * @see Statement#getResultSet
     * @see Statement#getUpdateCount
     * @see Statement#getMoreResults
     */
    public boolean execute() throws SQLException {
        return getPreparedStatement().execute();
    }

    /**
     * Sets the designated parameter to the given <code>Reader</code> object, which is the given number of characters
     * long. When a very large UNICODE value is input to a <code>LONGVARCHAR</code> parameter, it may be more practical
     * to send it via a
     * <code>java.io.Reader</code> object. The data will be read from the stream
     * as needed until end-of-file is reached.  The JDBC driver will do any necessary conversion from UNICODE to the
     * database char format.
     *
     * <P><B>Note:</B> This stream object can either be a standard
     * Java stream object or your own subclass that implements the standard interface.
     *
     * @param parameterName The name of the parameter.
     * @param reader        the <code>java.io.Reader</code> object that contains the Unicode data
     * @param length        the number of characters in the stream
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setCharacterStream(String parameterName, Reader reader, int length) throws SQLException {
        changeWithCheckedName(parameterName, reader, length, (name, in, len) -> valueMap.put(name, new ReaderValue(in, len)));
    }

    /**
     * Sets the designated parameter to the given
     * <code>REF(&lt;structured-type&gt;)</code> value.
     * The driver converts this to an SQL <code>REF</code> value when it sends it to the database.
     *
     * @param parameterName The name of the parameter.
     * @param value         an SQL <code>REF</code> value
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setRef(String parameterName, Ref value) throws SQLException {
        changeWithCheckedName(parameterName, value, (name, val) -> valueMap.put(name, new RefValue(val)));
    }

    /**
     * Sets the designated parameter to the given <code>java.sql.Blob</code> object. The driver converts this to an SQL
     * <code>BLOB</code> value when it sends it to the database.
     *
     * @param parameterName The name of the parameter.
     * @param value         a <code>Blob</code> object that maps an SQL <code>BLOB</code> value
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setBlob(String parameterName, Blob value) throws SQLException {
        changeWithCheckedName(parameterName, value, (name, val) -> valueMap.put(name, new BlobValue(val)));
    }

    /**
     * Sets the designated parameter to the given <code>java.sql.Clob</code> object. The driver converts this to an SQL
     * <code>CLOB</code> value when it sends it to the database.
     *
     * @param parameterName The name of the parameter.
     * @param value         a <code>Clob</code> object that maps an SQL <code>BLOB</code> value
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setClob(String parameterName, Clob value) throws SQLException {
        changeWithCheckedName(parameterName, value, (name, val) -> valueMap.put(name, new ClobValue(val)));
    }

    /**
     * Sets the designated parameter to the given <code>java.sql.Array</code> object. The driver converts this to an
     * SQL
     * <code>ARRAY</code> value when it sends it to the database.
     *
     * @param parameterName The name of the parameter.
     * @param value         an <code>Array</code> object that maps an SQL <code>ARRAY</code> value
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setArray(String parameterName, Array value) throws SQLException {
        changeWithCheckedName(parameterName, value, (name, val) -> valueMap.put(name, new ArrayValue(val)));
    }

    /**
     * Retrieves a <code>ResultSetMetaData</code> object that contains information about the columns of the
     * <code>ResultSet</code> object that will be returned when this <code>PreparedStatement</code> object is executed.
     * <p>
     * Because a <code>PreparedStatement</code> object is precompiled, it is possible to know about the
     * <code>ResultSet</code> object that it will return without having to execute it.  Consequently, it is possible to
     * invoke the method <code>getMetaData</code> on a
     * <code>PreparedStatement</code> object rather than waiting to execute
     * it and then invoking the <code>ResultSet.getMetaData</code> method on the <code>ResultSet</code> object that is
     * returned.
     * <p>
     * <B>NOTE:</B> Using this method may be expensive for some drivers due
     * to the lack of underlying DBMS support.
     *
     * @return the description of a <code>ResultSet</code> object's columns or
     * <code>null</code> if the driver cannot return a
     * <code>ResultSetMetaData</code> object
     * @throws SQLException                    if a database access error occurs or this method is called on a closed
     *                                         <code>PreparedStatement</code>
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     */
    public ResultSetMetaData getMetaData() throws SQLException {
        return getPreparedStatement().getMetaData();
    }

    /**
     * Sets the designated parameter to the given <code>java.sql.Date</code> value, using the given
     * <code>Calendar</code> object.  The driver uses the <code>Calendar</code> object to construct an SQL
     * <code>DATE</code> value, which the driver then sends to the database.  With a <code>Calendar</code> object, the
     * driver can calculate the date taking into account a custom timezone.  If no
     * <code>Calendar</code> object is specified, the driver uses the default
     * timezone, which is that of the virtual machine running the application.
     *
     * @param parameterName The name of the parameter.
     * @param value         the parameter value
     * @param calendar      the <code>Calendar</code> object the driver will use to construct the date
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setDate(String parameterName, Date value, Calendar calendar) throws SQLException {
        changeWithCheckedName(parameterName, value, calendar, (name, val, cal) -> valueMap.put(name, new DateValue(val, cal)));
    }

    /**
     * Sets the designated parameter to the given <code>java.sql.Time</code> value, using the given
     * <code>Calendar</code> object.  The driver uses the <code>Calendar</code> object to construct an SQL
     * <code>TIME</code> value, which the driver then sends to the database.  With a <code>Calendar</code> object, the
     * driver can calculate the time taking into account a custom timezone.  If no
     * <code>Calendar</code> object is specified, the driver uses the default
     * timezone, which is that of the virtual machine running the application.
     *
     * @param parameterName The name of the parameter.
     * @param time          the parameter value
     * @param calendar      the <code>Calendar</code> object the driver will use to construct the time
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setTime(String parameterName, Time time, Calendar calendar) throws SQLException {
        changeWithCheckedName(parameterName, time, calendar, (name, tm, cal) -> valueMap.put(name, new TimeValue(tm, cal)));
    }

    /**
     * Sets the designated parameter to the given <code>java.sql.Timestamp</code> value, using the given
     * <code>Calendar</code> object.  The driver uses the <code>Calendar</code> object to construct an SQL
     * <code>TIMESTAMP</code> value, which the driver then sends to the database.  With a
     * <code>Calendar</code> object, the driver can calculate the timestamp
     * taking into account a custom timezone.  If no
     * <code>Calendar</code> object is specified, the driver uses the default
     * timezone, which is that of the virtual machine running the application.
     *
     * @param parameterName The name of the parameter.
     * @param timestamp     the parameter value
     * @param calendar      the <code>Calendar</code> object the driver will use to construct the timestamp
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setTimestamp(String parameterName, Timestamp timestamp, Calendar calendar) throws SQLException {
        changeWithCheckedName(parameterName, timestamp, calendar, (name, ts, cal) -> valueMap.put(name, new TimestampValue(ts, cal)));
    }

    /**
     * Sets the designated parameter to SQL <code>NULL</code>. This version of the method <code>setNull</code> should be
     * used for user-defined types and REF type parameters.  Examples of user-defined types include: STRUCT, DISTINCT,
     * JAVA_OBJECT, and named array types.
     *
     * <P><B>Note:</B> To be portable, applications must give the
     * SQL type code and the fully-qualified SQL type name when specifying a NULL user-defined or REF parameter.  In the
     * case of a user-defined type the name is the type name of the parameter itself.  For a REF parameter, the name is
     * the type name of the referenced type.  If a JDBC driver does not need the type code or type name information, it
     * may ignore it.
     * <p>
     * Although it is intended for user-defined and Ref parameters, this method may be used to set a null parameter of
     * any JDBC type. If the parameter does not have a user-defined or REF type, the given typeName is ignored.
     *
     * @param parameterName The name of the parameter.
     * @param sqlType       a value from <code>java.sql.Types</code>
     * @param typeName      the fully-qualified name of an SQL user-defined type; ignored if the parameter is not a
     *                      user-defined type or REF
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setNull(String parameterName, int sqlType, String typeName) throws SQLException {
        changeWithCheckedName(parameterName, sqlType, typeName, (name, type, tn) -> valueMap.put(name, new NullValue(type, tn)));
    }

    /**
     * Sets the designated parameter to the given <code>java.net.URL</code> value. The driver converts this to an SQL
     * <code>DATALINK</code> value when it sends it to the database.
     *
     * @param parameterName The name of the parameter.
     * @param url           the <code>java.net.URL</code> object to be set
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setURL(String parameterName, URL url) throws SQLException {
        changeWithCheckedName(parameterName, url, (name, u) -> valueMap.put(name, new UrlValue(u)));
    }

    /**
     * Retrieves the number, types and properties of this
     * <code>PreparedStatement</code> object's parameters.
     *
     * @return a <code>ParameterMetaData</code> object that contains information about the number, types and properties
     * for each parameter marker of this <code>PreparedStatement</code> object
     * @throws SQLException if a database access error occurs or this method is called on a closed
     *                      <code>PreparedStatement</code>
     */
    public ParameterMetaData getParameterMetaData() throws SQLException {
        return getPreparedStatement().getParameterMetaData();
    }

    /**
     * Sets the designated parameter to the given <code>java.sql.RowId</code> object. The driver converts this to a SQL
     * <code>ROWID</code> value when it sends it to the database
     *
     * @param parameterName The name of the parameter.
     * @param rowId         the parameter value
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setRowId(String parameterName, RowId rowId) throws SQLException {
        changeWithCheckedName(parameterName, rowId, (name, id) -> valueMap.put(name, new RowIdValue(id)));
    }

    /**
     * Sets the designated parameter to the given <code>String</code> object. The driver converts this to a SQL
     * <code>NCHAR</code> or
     * <code>NVARCHAR</code> or <code>LONGNVARCHAR</code> value
     * (depending on the argument's size relative to the driver's limits on <code>NVARCHAR</code> values) when it sends
     * it to the database.
     *
     * @param parameterName The name of the parameter.
     * @param value         the parameter value
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setNString(String parameterName, String value) throws SQLException {
        changeWithCheckedName(parameterName, value, (name, val) -> valueMap.put(name, new NStringValue(val)));
    }

    /**
     * Sets the designated parameter to a <code>Reader</code> object. The
     * <code>Reader</code> reads the data till end-of-file is reached. The
     * driver does the necessary conversion from Java character format to the national character set in the database.
     *
     * @param parameterName The name of the parameter.
     * @param reader        the <code>java.io.Reader</code> object that contains the Unicode data
     * @param length        the number of characters in the stream
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setNCharacterStream(String parameterName, Reader reader, long length) throws SQLException {
        changeWithCheckedName(parameterName, reader, length, (name, in, len) -> valueMap.put(name, new NReaderValue(in, len)));
    }

    /**
     * Sets the designated parameter to a <code>java.sql.NClob</code> object. The driver converts this to a SQL
     * <code>NCLOB</code> value when it sends it to the database.
     *
     * @param parameterName The name of the parameter.
     * @param value         the parameter value
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setNClob(String parameterName, NClob value) throws SQLException {
        changeWithCheckedName(parameterName, value, (name, val) -> valueMap.put(name, new NClobValue(val)));
    }

    /**
     * Sets the designated parameter to a <code>Reader</code> object.  The reader must contain  the number of characters
     * specified by length otherwise a <code>SQLException</code> will be generated when the
     * <code>PreparedStatement</code> is executed. This method differs from the <code>setCharacterStream (int, Reader,
     * int)</code> method because it informs the driver that the parameter value should be sent to the server as a
     * <code>CLOB</code>.  When the <code>setCharacterStream</code> method is used, the driver may have to do extra
     * work to determine whether the parameter data should be sent to the server as a <code>LONGVARCHAR</code> or a
     * <code>CLOB</code>
     *
     * @param parameterName The name of the parameter.
     * @param reader        An object that contains the data to set the parameter value to.
     * @param length        the number of characters in the parameter data.
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setClob(String parameterName, Reader reader, long length) throws SQLException {
        changeWithCheckedName(parameterName, reader, length, (name, rdr, len) -> valueMap.put(name, new ClobValue(rdr, len)));
    }

    /**
     * Sets the designated parameter to a <code>InputStream</code> object.  The inputstream must contain  the number of
     * characters specified by length otherwise a <code>SQLException</code> will be generated when the
     * <code>PreparedStatement</code> is executed. This method differs from the <code>setBinaryStream (int,
     * InputStream, int)</code> method because it informs the driver that the parameter value should be sent to the
     * server as a
     * <code>BLOB</code>.  When the <code>setBinaryStream</code> method is used, the driver may have to do extra work
     * to determine whether the parameter data should be sent to the server as a <code>LONGVARBINARY</code> or a
     * <code>BLOB</code>
     *
     * @param parameterName The name of the parameter.
     * @param inputStream   An object that contains the data to set the parameter value to.
     * @param length        the number of bytes in the parameter data.
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setBlob(String parameterName, InputStream inputStream, long length) throws SQLException {
        changeWithCheckedName(parameterName, inputStream, length, (name, in, len) -> valueMap.put(name, new BlobValue(in, len)));
    }

    /**
     * Sets the designated parameter to a <code>Reader</code> object.  The reader must contain  the number of characters
     * specified by length otherwise a <code>SQLException</code> will be generated when the
     * <code>PreparedStatement</code> is executed. This method differs from the <code>setCharacterStream (int, Reader,
     * int)</code> method because it informs the driver that the parameter value should be sent to the server as a
     * <code>NCLOB</code>.  When the <code>setCharacterStream</code> method is used, the driver may have to do extra
     * work to determine whether the parameter data should be sent to the server as a <code>LONGNVARCHAR</code> or a
     * <code>NCLOB</code>
     *
     * @param parameterName The name of the parameter.
     * @param reader        An object that contains the data to set the parameter value to.
     * @param length        the number of characters in the parameter data.
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setNClob(String parameterName, Reader reader, long length) throws SQLException {
        changeWithCheckedName(parameterName, reader, length, (name, rdr, len) -> valueMap.put(name, new NClobValue(rdr, len)));
    }

    /**
     * Sets the designated parameter to the given <code>java.sql.SQLXML</code> object. The driver converts this to an
     * SQL <code>XML</code> value when it sends it to the database.
     * <p>
     *
     * @param parameterName The name of the parameter.
     * @param xmlObject     a <code>SQLXML</code> object that maps an SQL <code>XML</code> value
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setSQLXML(String parameterName, SQLXML xmlObject) throws SQLException {
        changeWithCheckedName(parameterName, xmlObject, (name, xml) -> valueMap.put(name, new SQLXMLValue(xml)));
    }

    /**
     * <p>Sets the value of the designated parameter with the given object.
     * <p>
     * If the second argument is an <code>InputStream</code> then the stream must contain the number of bytes specified
     * by scaleOrLength.  If the second argument is a
     * <code>Reader</code> then the reader must contain the number of characters specified
     * by scaleOrLength. If these conditions are not true the driver will generate a
     * <code>SQLException</code> when the prepared statement is executed.
     *
     * <p>The given Java object will be converted to the given targetSqlType
     * before being sent to the database.
     * <p>
     * If the object has a custom mapping (is of a class implementing the interface <code>SQLData</code>), the JDBC
     * driver should call the method <code>SQLData.writeSQL</code> to write it to the SQL data stream. If, on the other
     * hand, the object is of a class implementing
     * <code>Ref</code>, <code>Blob</code>, <code>Clob</code>,  <code>NClob</code>,
     * <code>Struct</code>, <code>java.net.URL</code>,
     * or <code>Array</code>, the driver should pass it to the database as a value of the corresponding SQL type.
     *
     * <p>Note that this method may be used to pass database-specific
     * abstract data types.
     *
     * @param parameterName The name of the parameter.
     * @param object        the object containing the input parameter value
     * @param targetSqlType the SQL type (as defined in java.sql.Types) to be sent to the database. The scale argument
     *                      may further qualify this type.
     * @param scaleOrLength for <code>java.sql.Types.DECIMAL</code> or <code>java.sql.Types.NUMERIC types</code>, this
     *                      is the number of digits after the decimal point. For Java Object types
     *                      <code>InputStream</code> and <code>Reader</code>, this is the length of the data in the
     *                      stream or reader.  For all other types, this value will be ignored.
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     * @see Types
     */
    public void setObject(String parameterName, Object object, int targetSqlType, int scaleOrLength) throws SQLException {
        changeWithCheckedName(parameterName, object, targetSqlType, scaleOrLength, (name, obj, type, scale) -> valueMap.put(name, new ObjectValue(obj, type, scale)));
    }

    /**
     * Sets the designated parameter to the given input stream, which will have the specified number of bytes. When a
     * very large ASCII value is input to a <code>LONGVARCHAR</code> parameter, it may be more practical to send it via
     * a
     * <code>java.io.InputStream</code>. Data will be read from the stream
     * as needed until end-of-file is reached.  The JDBC driver will do any necessary conversion from ASCII to the
     * database char format.
     *
     * <P><B>Note:</B> This stream object can either be a standard
     * Java stream object or your own subclass that implements the standard interface.
     *
     * @param parameterName The name of the parameter.
     * @param inputStream   the Java input stream that contains the ASCII parameter value
     * @param length        the number of bytes in the stream
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setAsciiStream(String parameterName, InputStream inputStream, long length) throws SQLException {
        changeWithCheckedName(parameterName, inputStream, length, (name, in, len) -> valueMap.put(name, new AsciiStreamValue(in, len)));
    }

    /**
     * Sets the designated parameter to the given input stream, which will have the specified number of bytes. When a
     * very large binary value is input to a <code>LONGVARBINARY</code> parameter, it may be more practical to send it
     * via a
     * <code>java.io.InputStream</code> object. The data will be read from the
     * stream as needed until end-of-file is reached.
     *
     * <P><B>Note:</B> This stream object can either be a standard
     * Java stream object or your own subclass that implements the standard interface.
     *
     * @param parameterName The name of the parameter.
     * @param inputStream   the java input stream which contains the binary parameter value
     * @param length        the number of bytes in the stream
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setBinaryStream(@NotNull String parameterName, @NotNull InputStream inputStream, long length) throws SQLException {
        changeWithCheckedName(parameterName, inputStream, length, (name, in, len) -> valueMap.put(name, new BinaryStreamValue(in, len)));
    }

    /**
     * Sets the designated parameter to the given <code>Reader</code> object, which is the given number of characters
     * long. When a very large UNICODE value is input to a <code>LONGVARCHAR</code> parameter, it may be more practical
     * to send it via a <code>java.io.Reader</code> object. The data will be read from the stream as needed until
     * end-of-file is reached.  The JDBC driver will do any necessary conversion from UNICODE to the database char
     * format.
     *
     * <P><B>Note:</B> This stream object can either be a standard Java Reader object or your own subclass that
     * implements the standard interface.
     *
     * @param parameterName The name of the parameter.
     * @param reader        the <code>java.io.Reader</code> object that contains the Unicode data
     * @param length        the number of characters in the stream
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setCharacterStream(String parameterName, Reader reader, long length) throws SQLException {
        changeWithCheckedName(parameterName, reader, length, (name, rdr, len) -> valueMap.put(name, new ReaderValue(rdr, len)));
    }

    /**
     * Sets the designated parameter to the given input stream. When a very large ASCII value is input to a
     * <code>LONGVARCHAR</code> parameter, it may be more practical to send it via a code>java.io.InputStream</code>.
     * Data will be read from the stream as needed until end-of-file is reached.  The JDBC driver will do any necessary
     * conversion from ASCII to the database char format.
     *
     * <P><B>Note:</B> This stream object can either be a standard Java stream object or your own subclass that
     * implements the standard interface.
     * <P><B>Note:</B> Consult your JDBC driver documentation to determine if it might be more efficient to use a
     * version of <code>setAsciiStream</code> which takes a length parameter.
     *
     * @param parameterName The name of the parameter.
     * @param inputStream   the Java input stream that contains the ASCII parameter value
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setAsciiStream(String parameterName, InputStream inputStream) throws SQLException {
        changeWithCheckedName(parameterName, inputStream, (name, in) -> valueMap.put(name, new AsciiStreamValue(in)));
    }

    /**
     * Sets the designated parameter to the given input stream. When a very large binary value is input to a
     * <code>LONGVARBINARY</code> parameter, it may be more practical to send it via a
     * <code>java.io.InputStream</code> object. The data will be read from the
     * stream as needed until end-of-file is reached.
     *
     * <P><B>Note:</B> This stream object can either be a standard
     * Java stream object or your own subclass that implements the standard interface.
     * <P><B>Note:</B> Consult your JDBC driver documentation to determine if
     * it might be more efficient to use a version of
     * <code>setBinaryStream</code> which takes a length parameter.
     *
     * @param parameterName The name of the parameter.
     * @param inputStream   the java input stream which contains the binary parameter value
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setBinaryStream(String parameterName, InputStream inputStream) throws SQLException {
        changeWithCheckedName(parameterName, inputStream, (name, in) -> valueMap.put(name, new BinaryStreamValue(in)));
    }

    /**
     * Sets the designated parameter to the given <code>Reader</code> object. When a very large UNICODE value is input
     * to a <code>LONGVARCHAR</code> parameter, it may be more practical to send it via a
     * <code>java.io.Reader</code> object. The data will be read from the stream
     * as needed until end-of-file is reached.  The JDBC driver will do any necessary conversion from UNICODE to the
     * database char format.
     *
     * <P><B>Note:</B> This stream object can either be a standard
     * Java stream object or your own subclass that implements the standard interface.
     * <P><B>Note:</B> Consult your JDBC driver documentation to determine if
     * it might be more efficient to use a version of
     * <code>setCharacterStream</code> which takes a length parameter.
     *
     * @param parameterName The name of the parameter.
     * @param reader        the <code>java.io.Reader</code> object that contains the Unicode data
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setCharacterStream(String parameterName, Reader reader) throws SQLException {
        changeWithCheckedName(parameterName, reader, (name, rdr) -> valueMap.put(name, new ReaderValue(rdr)));
    }

    /**
     * Sets the designated parameter to a <code>Reader</code> object. The
     * <code>Reader</code> reads the data till end-of-file is reached. The
     * driver does the necessary conversion from Java character format to the national character set in the database.
     *
     * <P><B>Note:</B> This stream object can either be a standard
     * Java stream object or your own subclass that implements the standard interface.
     * <P><B>Note:</B> Consult your JDBC driver documentation to determine if
     * it might be more efficient to use a version of
     * <code>setNCharacterStream</code> which takes a length parameter.
     *
     * @param parameterName The name of the parameter.
     * @param reader        the parameter reader
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setNCharacterStream(String parameterName, Reader reader) throws SQLException {
        changeWithCheckedName(parameterName, reader, (name, rdr) -> valueMap.put(name, new NReaderValue(rdr)));
    }

    /**
     * Sets the designated parameter to a <code>Reader</code> object. This method differs from the
     * <code>setCharacterStream (int, Reader)</code> method because it informs the driver that the parameter value
     * should be sent to the server as a <code>CLOB</code>.  When the <code>setCharacterStream</code> method is used,
     * the driver may have to do extra work to determine whether the parameter data should be sent to the server as a
     * <code>LONGVARCHAR</code> or a <code>CLOB</code>
     *
     * <P><B>Note:</B> Consult your JDBC driver documentation to determine if
     * it might be more efficient to use a version of
     * <code>setClob</code> which takes a length parameter.
     *
     * @param parameterName The name of the parameter.
     * @param reader        An object that contains the data to set the parameter value to.
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setClob(String parameterName, Reader reader) throws SQLException {
        changeWithCheckedName(parameterName, reader, (name, rdr) -> valueMap.put(name, new ClobValue(rdr)));
    }

    /**
     * Sets the designated parameter to a <code>InputStream</code> object. This method differs from the
     * <code>setBinaryStream (int, InputStream)</code> method because it informs the driver that the parameter value
     * should be sent to the server as a <code>BLOB</code>.  When the <code>setBinaryStream</code> method is used, the
     * driver may have to do extra work to determine whether the parameter data should be sent to the server as a
     * <code>LONGVARBINARY</code> or a <code>BLOB</code>
     *
     * <P><B>Note:</B> Consult your JDBC driver documentation to determine if
     * it might be more efficient to use a version of
     * <code>setBlob</code> which takes a length parameter.
     *
     * @param parameterName The name of the parameter.
     * @param inputStream   An object that contains the data to set the parameter value to.
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setBlob(String parameterName, InputStream inputStream) throws SQLException {
        changeWithCheckedName(parameterName, inputStream, (name, in) -> valueMap.put(name, new BlobValue(in)));
    }

    /**
     * Sets the designated parameter to a <code>Reader</code> object. This method differs from the
     * <code>setCharacterStream (int, Reader)</code> method because it informs the driver that the parameter value
     * should be sent to the server as a <code>NCLOB</code>.  When the <code>setCharacterStream</code> method is used,
     * the driver may have to do extra work to determine whether the parameter data should be sent to the server as a
     * <code>LONGNVARCHAR</code> or a <code>NCLOB</code>
     * <P><B>Note:</B> Consult your JDBC driver documentation to determine if
     * it might be more efficient to use a version of
     * <code>setNClob</code> which takes a length parameter.
     *
     * @param parameterName The name of the parameter.
     * @param reader        An object that contains the data to set the parameter value to.
     * @throws SQLException If parameterName does not correspond to a variable in the SmilelyVars template.
     */
    public void setNClob(String parameterName, Reader reader) throws SQLException {
        changeWithCheckedName(parameterName, reader, (name, rdr) -> valueMap.put(name, new NClobValue(rdr)));
    }

    /**
     * Executes the given SQL statement, which returns a single <code>ResultSet</code> object.
     * <p>
     * <strong>Note:</strong>This method cannot be called on a
     * <code>PreparedStatement</code> or <code>CallableStatement</code>.
     *
     * @param sql an SQL statement to be sent to the database, typically a static SQL <code>SELECT</code> statement
     * @return a <code>ResultSet</code> object that contains the data produced by the given query; never
     * <code>null</code>
     * @throws SQLException        if a database access error occurs, this method is called on a closed
     *                             <code>Statement</code>, the given SQL statement produces anything other than a
     *                             single <code>ResultSet</code> object, the method is called on a
     *                             <code>PreparedStatement</code> or <code>CallableStatement</code>
     * @throws SQLTimeoutException when the driver has determined that the timeout value that was specified by the
     *                             {@code setQueryTimeout} method has been exceeded and has at least attempted to cancel
     *                             the currently running {@code Statement}
     */
    public ResultSet executeQuery(String sql) throws SQLException {
        return getPreparedStatement().executeQuery(sql);
    }

    /**
     * Executes the given SQL statement, which may be an <code>INSERT</code>,
     * <code>UPDATE</code>, or <code>DELETE</code> statement or an
     * SQL statement that returns nothing, such as an SQL DDL statement.
     * <p>
     * <strong>Note:</strong>This method cannot be called on a
     * <code>PreparedStatement</code> or <code>CallableStatement</code>.
     *
     * @param sql an SQL Data Manipulation Language (DML) statement, such as <code>INSERT</code>, <code>UPDATE</code>
     *            or
     *            <code>DELETE</code>; or an SQL statement that returns nothing,
     *            such as a DDL statement.
     * @return either (1) the row count for SQL Data Manipulation Language (DML) statements or (2) 0 for SQL statements
     * that return nothing
     * @throws SQLException        if a database access error occurs, this method is called on a closed
     *                             <code>Statement</code>, the given SQL statement produces a <code>ResultSet</code>
     *                             object, the method is called on a
     *                             <code>PreparedStatement</code> or <code>CallableStatement</code>
     * @throws SQLTimeoutException when the driver has determined that the timeout value that was specified by the
     *                             {@code setQueryTimeout} method has been exceeded and has at least attempted to cancel
     *                             the currently running {@code Statement}
     */
    public int executeUpdate(String sql) throws SQLException {
        return getPreparedStatement().executeUpdate(sql);
    }

    /**
     * Releases the underlying <code>PreparedStatement</code> objects. This also clears all of the parameter values that
     * have been provided. It is generally good practice to close this object soon as you are finished with it to avoid
     * tying up database resources.
     *
     * @throws SQLException if a database access error occurs
     * @see #clearParameters()
     */
    @Override
    public void close() throws SQLException {
        Iterator<Map.Entry<BitSet, PreparedStatementTag>> iterator = taggedPstmtMap.entrySet().iterator();
        while (iterator.hasNext()) {
            iterator.next().getValue().getPreparedStatement().close();
            iterator.remove();
        }
        clearParameters();
        closed = true;
    }

    /**
     * Clears the current parameter values immediately. This just clears the values that have been set for SmileyVars.
     * If this is being done to release resources, call {@link #deepClearParameters()}, which also clears the parameter
     * values in the underlying {@link PreparedStatement} objects.
     *
     * @see #deepClearParameters()
     */
    public void clearParameters() {
        valueMap.entrySet().forEach(entry -> entry.setValue(null));
    }

    /**
     * Clears the current parameter values immediately. This clears both the values that have been set for Smileyvars
     * and the parameter values in the underlying {@link PreparedStatement} objects. This can be useful for releasing
     * the resources used by the current parameter values.
     *
     * @throws SQLException if a database access error occurs or this method is called on a closed
     *                      <code>PreparedStatement</code>
     * @see #clearParameters()
     */
    public void deepClearParameters() throws SQLException {
        clearParameters();
        for (PreparedStatementTag pTag : taggedPstmtMap.values()) {
            pTag.getPreparedStatement().close();
        }
    }

    /**
     * Retrieves the maximum number of bytes that can be returned for character and binary column values in a
     * <code>ResultSet</code> object produced by this <code>Statement</code> object. This limit applies only to
     * <code>BINARY</code>, <code>VARBINARY</code>, <code>LONGVARBINARY</code>, <code>CHAR</code>,
     * <code>VARCHAR</code>,  <code>NCHAR</code>, <code>NVARCHAR</code>, <code>LONGNVARCHAR</code>
     * and <code>LONGVARCHAR</code> columns.  If the limit is exceeded, the excess data is silently discarded.
     *
     * @return the current column size limit for columns storing character and binary values; zero means there is no
     * limit
     * @throws SQLException if a database access error occurs or this method is called on a closed
     *                      <code>Statement</code>
     * @see #setMaxFieldSize
     */
    public int getMaxFieldSize() throws SQLException {
        return getPreparedStatement().getMaxFieldSize();
    }

    /**
     * Sets the limit for the maximum number of bytes that can be returned for character and binary column values in a
     * <code>ResultSet</code> object produced by this <code>Statement</code> object.
     * <p>
     * This limit applies only to <code>BINARY</code>, <code>VARBINARY</code>,
     * <code>LONGVARBINARY</code>, <code>CHAR</code>, <code>VARCHAR</code>,
     * <code>NCHAR</code>, <code>NVARCHAR</code>, <code>LONGNVARCHAR</code> and
     * <code>LONGVARCHAR</code> fields.  If the limit is exceeded, the excess data
     * is silently discarded. For maximum portability, use values greater than 256.
     *
     * @param max the new column size limit in bytes; zero means there is no limit
     * @throws SQLException if a database access error occurs, this method is called on a closed <code>Statement</code>
     *                      or the condition {@code max >= 0} is not satisfied
     * @see #getMaxFieldSize
     */
    public void setMaxFieldSize(int max) throws SQLException {
        //TODO finish this
    }

    /**
     * Retrieves the maximum number of rows that a <code>ResultSet</code> object produced by this
     * <code>Statement</code> object can contain.  If this limit is exceeded, the excess rows are silently dropped.
     *
     * @return the current maximum number of rows for a <code>ResultSet</code> object produced by this
     * <code>Statement</code> object;
     * zero means there is no limit
     * @throws SQLException if a database access error occurs or this method is called on a closed
     *                      <code>Statement</code>
     * @see #setMaxRows
     */
    public int getMaxRows() throws SQLException {
        return getPreparedStatement().getMaxRows();
    }

    /**
     * Sets the limit for the maximum number of rows that any
     * <code>ResultSet</code> object  generated by this <code>Statement</code>
     * object can contain to the given number. If the limit is exceeded, the excess rows are silently dropped.
     *
     * @param max the new max rows limit; zero means there is no limit
     * @throws SQLException if a database access error occurs, this method is called on a closed <code>Statement</code>
     *                      or the condition {@code max >= 0} is not satisfied
     * @see #getMaxRows
     */
    public void setMaxRows(int max) throws SQLException {
        //TODO finish this
    }

    /**
     * Sets escape processing on or off. If escape scanning is on (the default), the driver will do escape substitution
     * before sending the SQL statement to the database.
     * <p>
     * The {@code Connection} and {@code DataSource} property {@code escapeProcessing} may be used to change the default
     * escape processing behavior.  A value of true (the default) enables escape Processing for all {@code Statement}
     * objects. A value of false disables escape processing for all {@code Statement} objects.  The {@code
     * setEscapeProcessing} method may be used to specify the escape processing behavior for an individual {@code
     * Statement} object.
     * <p>
     * Note: Since prepared statements have usually been parsed prior to making this call, disabling escape processing
     * for
     * <code>PreparedStatements</code> objects will have no effect.
     *
     * @param enable <code>true</code> to enable escape processing;
     *               <code>false</code> to disable it
     * @throws SQLException if a database access error occurs or this method is called on a closed
     *                      <code>Statement</code>
     */
    public void setEscapeProcessing(boolean enable) throws SQLException {
        //TODO finish this
    }

    /**
     * Retrieves the number of seconds the driver will wait for a <code>Statement</code> object to execute. If the limit
     * is exceeded, a
     * <code>SQLException</code> is thrown.
     *
     * @return the current query timeout limit in seconds; zero means there is no limit
     * @throws SQLException if a database access error occurs or this method is called on a closed
     *                      <code>Statement</code>
     * @see #setQueryTimeout
     */
    public int getQueryTimeout() throws SQLException {
        return getPreparedStatement().getQueryTimeout();
    }

    /**
     * Sets the number of seconds the driver will wait for a
     * <code>Statement</code> object to execute to the given number of seconds.
     * By default there is no limit on the amount of time allowed for a running statement to complete. If the limit is
     * exceeded, an
     * <code>SQLTimeoutException</code> is thrown.
     * A JDBC driver must apply this limit to the <code>execute</code>,
     * <code>executeQuery</code> and <code>executeUpdate</code> methods.
     * <p>
     * <strong>Note:</strong> JDBC driver implementations may also apply this
     * limit to {@code ResultSet} methods (consult your driver vendor documentation for details).
     * <p>
     * <strong>Note:</strong> In the case of {@code Statement} batching, it is
     * implementation defined as to whether the time-out is applied to individual SQL commands added via the {@code
     * addBatch} method or to the entire batch of SQL commands invoked by the {@code executeBatch} method (consult your
     * driver vendor documentation for details).
     *
     * @param seconds the new query timeout limit in seconds; zero means there is no limit
     * @throws SQLException if a database access error occurs, this method is called on a closed <code>Statement</code>
     *                      or the condition {@code seconds >= 0} is not satisfied
     * @see #getQueryTimeout
     */
    public void setQueryTimeout(int seconds) throws SQLException {
        //TODO finish this
    }

    /**
     * Retrieves the first warning reported by calls on this <code>Statement</code> object. Subsequent
     * <code>Statement</code> object warnings will be chained to this
     * <code>SQLWarning</code> object.
     *
     * <p>The warning chain is automatically cleared each time
     * a statement is (re)executed. This method may not be called on a closed
     * <code>Statement</code> object; doing so will cause an <code>SQLException</code>
     * to be thrown.
     *
     * <P><B>Note:</B> If you are processing a <code>ResultSet</code> object, any
     * warnings associated with reads on that <code>ResultSet</code> object will be chained on it rather than on the
     * <code>Statement</code> object that produced it.
     *
     * @return the first <code>SQLWarning</code> object or <code>null</code> if there are no warnings
     * @throws SQLException if a database access error occurs or this method is called on a closed
     *                      <code>Statement</code>
     */

    public SQLWarning getWarnings() throws SQLException {
        //TODO finish this
        return null;
    }

    /**
     * Clears all the warnings reported on this <code>Statement</code> object. After a call to this method, the method
     * <code>getWarnings</code> will return
     * <code>null</code> until a new warning is reported for this
     * <code>Statement</code> object.
     *
     * @throws SQLException if a database access error occurs or this method is called on a closed
     *                      <code>Statement</code>
     */
    public void clearWarnings() throws SQLException {
        //TODO finish this
    }

    /**
     * Sets the SQL cursor name to the given <code>String</code>, which will be used by subsequent
     * <code>Statement</code> object
     * <code>execute</code> methods. This name can then be
     * used in SQL positioned update or delete statements to identify the current row in the <code>ResultSet</code>
     * object generated by this statement.  If the database does not support positioned update/delete, this method is a
     * noop.  To insure that a cursor has the proper isolation level to support updates, the cursor's
     * <code>SELECT</code> statement should have the form <code>SELECT FOR UPDATE</code>.  If
     * <code>FOR UPDATE</code> is not present, positioned updates may fail.
     *
     * <P><B>Note:</B> By definition, the execution of positioned updates and
     * deletes must be done by a different <code>Statement</code> object than the one that generated the
     * <code>ResultSet</code> object being used for positioning. Also, cursor names must be unique within a connection.
     *
     * @param name the new cursor name, which must be unique within a connection
     * @throws SQLException                    if a database access error occurs or this method is called on a closed
     *                                         <code>Statement</code>
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     */
    public void setCursorName(String name) throws SQLException {
        //TODO finish this
    }

    /**
     * Executes the given SQL statement, which may return multiple results. In some (uncommon) situations, a single SQL
     * statement may return multiple result sets and/or update counts.  Normally you can ignore this unless you are (1)
     * executing a stored procedure that you know may return multiple results or (2) you are dynamically executing an
     * unknown SQL string.
     * <p>
     * The <code>execute</code> method executes an SQL statement and indicates the form of the first result.  You must
     * then use the methods
     * <code>getResultSet</code> or <code>getUpdateCount</code>
     * to retrieve the result, and <code>getMoreResults</code> to move to any subsequent result(s).
     * <p>
     * <strong>Note:</strong>This method cannot be called on a
     * <code>PreparedStatement</code> or <code>CallableStatement</code>.
     *
     * @param sql any SQL statement
     * @return <code>true</code> if the first result is a <code>ResultSet</code>
     * object; <code>false</code> if it is an update count or there are no results
     * @throws SQLException        if a database access error occurs, this method is called on a closed
     *                             <code>Statement</code>, the method is called on a
     *                             <code>PreparedStatement</code> or <code>CallableStatement</code>
     * @throws SQLTimeoutException when the driver has determined that the timeout value that was specified by the
     *                             {@code setQueryTimeout} method has been exceeded and has at least attempted to cancel
     *                             the currently running {@code Statement}
     * @see #getResultSet
     * @see #getUpdateCount
     * @see #getMoreResults
     */
    public boolean execute(String sql) throws SQLException {
        return getPreparedStatement().execute(sql);
    }

    /**
     * Retrieves the current result as a <code>ResultSet</code> object. This method should be called only once per
     * result.
     *
     * @return the current result as a <code>ResultSet</code> object or
     * <code>null</code> if the result is an update count or there are no more results
     * @throws SQLException if a database access error occurs or this method is called on a closed
     *                      <code>Statement</code>
     * @see #execute
     */
    public ResultSet getResultSet() throws SQLException {
        return getPreparedStatement().getResultSet();
    }

    /**
     * Retrieves the current result as an update count; if the result is a <code>ResultSet</code> object or there are no
     * more results, -1 is returned. This method should be called only once per result.
     *
     * @return the current result as an update count; -1 if the current result is a
     * <code>ResultSet</code> object or there are no more results
     * @throws SQLException if a database access error occurs or this method is called on a closed
     *                      <code>Statement</code>
     * @see #execute
     */
    public int getUpdateCount() throws SQLException {
        return getPreparedStatement().getUpdateCount();
    }

    /**
     * Moves to this <code>Statement</code> object's next result, returns
     * <code>true</code> if it is a <code>ResultSet</code> object, and
     * implicitly closes any current <code>ResultSet</code> object(s) obtained with the method
     * <code>getResultSet</code>.
     *
     * <P>There are no more results when the following is true:
     * <PRE>{@code
     * // stmt is a Statement object ((stmt.getMoreResults() == false) && (stmt.getUpdateCount() == -1)) }</PRE>
     *
     * @return <code>true</code> if the next result is a <code>ResultSet</code>
     * object; <code>false</code> if it is an update count or there are no more results
     * @throws SQLException if a database access error occurs or this method is called on a closed
     *                      <code>Statement</code>
     * @see #execute
     */
    public boolean getMoreResults() throws SQLException {
        return getPreparedStatement().getMoreResults();
    }

    /**
     * Retrieves the direction for fetching rows from database tables that is the default for result sets generated from
     * this <code>Statement</code> object. If this <code>Statement</code> object has not set a fetch direction by
     * calling the method <code>setFetchDirection</code>, the return value is implementation-specific.
     *
     * @return the default fetch direction for result sets generated from this <code>Statement</code> object
     * @throws SQLException if a database access error occurs or this method is called on a closed
     *                      <code>Statement</code>
     * @see #setFetchDirection
     */
    public int getFetchDirection() throws SQLException {
        return getPreparedStatement().getFetchDirection();
    }

    /**
     * Gives the driver a hint as to the direction in which rows will be processed in <code>ResultSet</code> objects
     * created using this <code>Statement</code> object.  The default value is <code>ResultSet.FETCH_FORWARD</code>.
     * <p>
     * Note that this method sets the default fetch direction for result sets generated by this <code>Statement</code>
     * object. Each result set has its own methods for getting and setting its own fetch direction.
     *
     * @param direction the initial direction for processing rows
     * @throws SQLException if a database access error occurs, this method is called on a closed <code>Statement</code>
     *                      or the given direction is not one of <code>ResultSet.FETCH_FORWARD</code>,
     *                      <code>ResultSet.FETCH_REVERSE</code>, or <code>ResultSet.FETCH_UNKNOWN</code>
     * @see #getFetchDirection
     */
    public void setFetchDirection(int direction) throws SQLException {
        //TODO finish this
    }

    /**
     * Retrieves the number of result set rows that is the default fetch size for <code>ResultSet</code> objects
     * generated from this <code>Statement</code> object. If this <code>Statement</code> object has not set a fetch size
     * by calling the method <code>setFetchSize</code>, the return value is implementation-specific.
     *
     * @return the default fetch size for result sets generated from this <code>Statement</code> object
     * @throws SQLException if a database access error occurs or this method is called on a closed
     *                      <code>Statement</code>
     * @see #setFetchSize
     */
    public int getFetchSize() throws SQLException {
        return getPreparedStatement().getFetchSize();
    }

    /**
     * Gives the JDBC driver a hint as to the number of rows that should be fetched from the database when more rows are
     * needed for
     * <code>ResultSet</code> objects generated by this <code>Statement</code>.
     * If the value specified is zero, then the hint is ignored. The default value is zero.
     *
     * @param rows the number of rows to fetch
     * @throws SQLException if a database access error occurs, this method is called on a closed <code>Statement</code>
     *                      or the condition {@code rows >= 0} is not satisfied.
     * @see #getFetchSize
     */
    @SuppressWarnings("WeakerAccess")
    public void setFetchSize(int rows) throws SQLException {
        //TODO finish this
    }

    /**
     * Retrieves the result set concurrency for <code>ResultSet</code> objects generated by this <code>Statement</code>
     * object.
     *
     * @return either <code>ResultSet.CONCUR_READ_ONLY</code> or
     * <code>ResultSet.CONCUR_UPDATABLE</code>
     * @throws SQLException if a database access error occurs or this method is called on a closed
     *                      <code>Statement</code>
     */
    public int getResultSetConcurrency() throws SQLException {
        return getPreparedStatement().getResultSetConcurrency();
    }

    /**
     * Retrieves the result set type for <code>ResultSet</code> objects generated by this <code>Statement</code>
     * object.
     *
     * @return one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
     * <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or
     * <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>
     * @throws SQLException if a database access error occurs or this method is called on a closed
     *                      <code>Statement</code>
     */
    public int getResultSetType() throws SQLException {
        return getPreparedStatement().getResultSetType();
    }

    /**
     * Retrieves the <code>Connection</code> object that produced this <code>Statement</code> object.
     *
     * @return the connection that produced this statement
     * @throws SQLException if a database access error occurs or this method is called on a closed
     *                      <code>Statement</code>
     */
    public Connection getConnection() throws SQLException {
        return connection;
    }

    /**
     * Moves to this <code>Statement</code> object's next result, deals with any current <code>ResultSet</code>
     * object(s) according  to the instructions specified by the given flag, and returns
     * <code>true</code> if the next result is a <code>ResultSet</code> object.
     *
     * <P>There are no more results when the following is true:
     * <PRE>{@code
     * // stmt is a Statement object ((stmt.getMoreResults(current) == false) && (stmt.getUpdateCount() == -1)) }</PRE>
     *
     * @param current one of the following <code>Statement</code> constants indicating what should happen to current
     *                <code>ResultSet</code> objects obtained using the method
     *                <code>getResultSet</code>:
     *                <code>Statement.CLOSE_CURRENT_RESULT</code>,
     *                <code>Statement.KEEP_CURRENT_RESULT</code>, or
     *                <code>Statement.CLOSE_ALL_RESULTS</code>
     * @return <code>true</code> if the next result is a <code>ResultSet</code>
     * object; <code>false</code> if it is an update count or there are no more results
     * @throws SQLException                    if a database access error occurs, this method is called on a closed
     *                                         <code>Statement</code> or the argument supplied is not one of the
     *                                         following:
     *                                         <code>Statement.CLOSE_CURRENT_RESULT</code>,
     *                                         <code>Statement.KEEP_CURRENT_RESULT</code> or
     *                                         <code>Statement.CLOSE_ALL_RESULTS</code>
     * @throws SQLFeatureNotSupportedException if
     *                                         <code>DatabaseMetaData.supportsMultipleOpenResults</code> returns
     *                                         <code>false</code> and either
     *                                         <code>Statement.KEEP_CURRENT_RESULT</code> or
     *                                         <code>Statement.CLOSE_ALL_RESULTS</code> are supplied as
     *                                         the argument.
     * @see #execute
     */
    public boolean getMoreResults(int current) throws SQLException {
        return getPreparedStatement().getMoreResults(current);
    }

    /**
     * Retrieves any auto-generated keys created as a result of executing this
     * <code>Statement</code> object. If this <code>Statement</code> object did
     * not generate any keys, an empty <code>ResultSet</code> object is returned.
     *
     * <p><B>Note:</B>If the columns which represent the auto-generated keys were not specified,
     * the JDBC driver implementation will determine the columns which best represent the auto-generated keys.
     *
     * @return a <code>ResultSet</code> object containing the auto-generated key(s) generated by the execution of this
     * <code>Statement</code> object
     * @throws SQLException                    if a database access error occurs or this method is called on a closed
     *                                         <code>Statement</code>
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     * @since 1.4
     */
    public ResultSet getGeneratedKeys() throws SQLException {
        return getPreparedStatement().getGeneratedKeys();
    }

    /**
     * Executes the given SQL statement and signals the driver with the given flag about whether the auto-generated keys
     * produced by this <code>Statement</code> object should be made available for retrieval.  The driver will ignore
     * the flag if the SQL statement is not an <code>INSERT</code> statement, or an SQL statement able to return
     * auto-generated keys (the list of such statements is vendor-specific).
     * <p>
     * <strong>Note:</strong>This method cannot be called on a
     * <code>PreparedStatement</code> or <code>CallableStatement</code>.
     *
     * @param sql               an SQL Data Manipulation Language (DML) statement, such as <code>INSERT</code>,
     *                          <code>UPDATE</code> or
     *                          <code>DELETE</code>; or an SQL statement that returns nothing,
     *                          such as a DDL statement.
     * @param autoGeneratedKeys a flag indicating whether auto-generated keys should be made available for retrieval;
     *                          one of the following constants:
     *                          <code>Statement.RETURN_GENERATED_KEYS</code>
     *                          <code>Statement.NO_GENERATED_KEYS</code>
     * @return either (1) the row count for SQL Data Manipulation Language (DML) statements or (2) 0 for SQL statements
     * that return nothing
     * @throws SQLException                    if a database access error occurs, this method is called on a closed
     *                                         <code>Statement</code>, the given SQL statement returns a
     *                                         <code>ResultSet</code> object, the given constant is not one of those
     *                                         allowed, the method is called on a
     *                                         <code>PreparedStatement</code> or <code>CallableStatement</code>
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method with a constant of
     *                                         Statement.RETURN_GENERATED_KEYS
     * @throws SQLTimeoutException             when the driver has determined that the timeout value that was specified
     *                                         by the {@code setQueryTimeout} method has been exceeded and has at least
     *                                         attempted to cancel the currently running {@code Statement}
     */
    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        return getPreparedStatement().executeUpdate(sql, autoGeneratedKeys);
    }

    /**
     * Executes the given SQL statement and signals the driver that the auto-generated keys indicated in the given array
     * should be made available for retrieval.   This array contains the indexes of the columns in the target table that
     * contain the auto-generated keys that should be made available. The driver will ignore the array if the SQL
     * statement is not an <code>INSERT</code> statement, or an SQL statement able to return auto-generated keys (the
     * list of such statements is vendor-specific).
     * <p>
     * <strong>Note:</strong>This method cannot be called on a
     * <code>PreparedStatement</code> or <code>CallableStatement</code>.
     *
     * @param sql           an SQL Data Manipulation Language (DML) statement, such as <code>INSERT</code>,
     *                      <code>UPDATE</code> or
     *                      <code>DELETE</code>; or an SQL statement that returns nothing,
     *                      such as a DDL statement.
     * @param columnIndexes an array of column indexes indicating the columns that should be returned from the inserted
     *                      row
     * @return either (1) the row count for SQL Data Manipulation Language (DML) statements or (2) 0 for SQL statements
     * that return nothing
     * @throws SQLException                    if a database access error occurs, this method is called on a closed
     *                                         <code>Statement</code>, the SQL statement returns a
     *                                         <code>ResultSet</code> object,the second argument supplied to this
     *                                         method is not an
     *                                         <code>int</code> array whose elements are valid column indexes, the
     *                                         method is called on a
     *                                         <code>PreparedStatement</code> or <code>CallableStatement</code>
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     * @throws SQLTimeoutException             when the driver has determined that the timeout value that was specified
     *                                         by the {@code setQueryTimeout} method has been exceeded and has at least
     *                                         attempted to cancel the currently running {@code Statement}
     */

    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
        return getPreparedStatement().executeUpdate(sql, columnIndexes);
    }

    /**
     * Executes the given SQL statement and signals the driver that the auto-generated keys indicated in the given array
     * should be made available for retrieval.   This array contains the names of the columns in the target table that
     * contain the auto-generated keys that should be made available. The driver will ignore the array if the SQL
     * statement is not an <code>INSERT</code> statement, or an SQL statement able to return auto-generated keys (the
     * list of such statements is vendor-specific).
     * <p>
     * <strong>Note:</strong>This method cannot be called on a
     * <code>PreparedStatement</code> or <code>CallableStatement</code>.
     *
     * @param sql         an SQL Data Manipulation Language (DML) statement, such as <code>INSERT</code>,
     *                    <code>UPDATE</code> or
     *                    <code>DELETE</code>; or an SQL statement that returns nothing,
     *                    such as a DDL statement.
     * @param columnNames an array of the names of the columns that should be returned from the inserted row
     * @return either the row count for <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> statements, or
     * 0 for SQL statements that return nothing
     * @throws SQLException                    if a database access error occurs, this method is called on a closed
     *                                         <code>Statement</code>, the SQL statement returns a
     *                                         <code>ResultSet</code> object, the second argument supplied to this
     *                                         method is not a <code>String</code> array whose elements are valid column
     *                                         names, the method is called on a
     *                                         <code>PreparedStatement</code> or <code>CallableStatement</code>
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     * @throws SQLTimeoutException             when the driver has determined that the timeout value that was specified
     *                                         by the {@code setQueryTimeout} method has been exceeded and has at least
     *                                         attempted to cancel the currently running {@code Statement}
     */
    public int executeUpdate(String sql, String[] columnNames) throws SQLException {
        return getPreparedStatement().executeUpdate(sql, columnNames);
    }

    /**
     * Executes the given SQL statement, which may return multiple results, and signals the driver that any
     * auto-generated keys should be made available for retrieval.  The driver will ignore this signal if the SQL
     * statement is not an <code>INSERT</code> statement, or an SQL statement able to return auto-generated keys (the
     * list of such statements is vendor-specific).
     * <p>
     * In some (uncommon) situations, a single SQL statement may return multiple result sets and/or update counts.
     * Normally you can ignore this unless you are (1) executing a stored procedure that you know may return multiple
     * results or (2) you are dynamically executing an unknown SQL string.
     * <p>
     * The <code>execute</code> method executes an SQL statement and indicates the form of the first result.  You must
     * then use the methods
     * <code>getResultSet</code> or <code>getUpdateCount</code>
     * to retrieve the result, and <code>getMoreResults</code> to move to any subsequent result(s).
     * <p>
     * <strong>Note:</strong>This method cannot be called on a
     * <code>PreparedStatement</code> or <code>CallableStatement</code>.
     *
     * @param sql               any SQL statement
     * @param autoGeneratedKeys a constant indicating whether auto-generated keys should be made available for retrieval
     *                          using the method
     *                          <code>getGeneratedKeys</code>; one of the following constants:
     *                          <code>Statement.RETURN_GENERATED_KEYS</code> or
     *                          <code>Statement.NO_GENERATED_KEYS</code>
     * @return <code>true</code> if the first result is a <code>ResultSet</code>
     * object; <code>false</code> if it is an update count or there are no results
     * @throws SQLException                    if a database access error occurs, this method is called on a closed
     *                                         <code>Statement</code>, the second parameter supplied to this method is
     *                                         not
     *                                         <code>Statement.RETURN_GENERATED_KEYS</code> or
     *                                         <code>Statement.NO_GENERATED_KEYS</code>,
     *                                         the method is called on a
     *                                         <code>PreparedStatement</code> or <code>CallableStatement</code>
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method with a constant of
     *                                         Statement.RETURN_GENERATED_KEYS
     * @throws SQLTimeoutException             when the driver has determined that the timeout value that was specified
     *                                         by the {@code setQueryTimeout} method has been exceeded and has at least
     *                                         attempted to cancel the currently running {@code Statement}
     * @see #getResultSet
     * @see #getUpdateCount
     * @see #getMoreResults
     * @see #getGeneratedKeys
     */
    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        return getPreparedStatement().execute(sql, autoGeneratedKeys);
    }

    /**
     * Executes the given SQL statement, which may return multiple results, and signals the driver that the
     * auto-generated keys indicated in the given array should be made available for retrieval.  This array contains the
     * indexes of the columns in the target table that contain the auto-generated keys that should be made available.
     * The driver will ignore the array if the SQL statement is not an <code>INSERT</code> statement, or an SQL
     * statement able to return auto-generated keys (the list of such statements is vendor-specific).
     * <p>
     * Under some (uncommon) situations, a single SQL statement may return multiple result sets and/or update counts.
     * Normally you can ignore this unless you are (1) executing a stored procedure that you know may return multiple
     * results or (2) you are dynamically executing an unknown SQL string.
     * <p>
     * The <code>execute</code> method executes an SQL statement and indicates the form of the first result.  You must
     * then use the methods
     * <code>getResultSet</code> or <code>getUpdateCount</code>
     * to retrieve the result, and <code>getMoreResults</code> to move to any subsequent result(s).
     * <p>
     * <strong>Note:</strong>This method cannot be called on a
     * <code>PreparedStatement</code> or <code>CallableStatement</code>.
     *
     * @param sql           any SQL statement
     * @param columnIndexes an array of the indexes of the columns in the inserted row that should be  made available
     *                      for retrieval by a call to the method <code>getGeneratedKeys</code>
     * @return <code>true</code> if the first result is a <code>ResultSet</code>
     * object; <code>false</code> if it is an update count or there are no results
     * @throws SQLException                    if a database access error occurs, this method is called on a closed
     *                                         <code>Statement</code>, the elements in the <code>int</code> array
     *                                         passed to this method are not valid column indexes, the method is called
     *                                         on a
     *                                         <code>PreparedStatement</code> or <code>CallableStatement</code>
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     * @throws SQLTimeoutException             when the driver has determined that the timeout value that was specified
     *                                         by the {@code setQueryTimeout} method has been exceeded and has at least
     *                                         attempted to cancel the currently running {@code Statement}
     * @see #getResultSet
     * @see #getUpdateCount
     * @see #getMoreResults
     */
    public boolean execute(String sql, int[] columnIndexes) throws SQLException {
        return getPreparedStatement().execute(sql, columnIndexes);
    }

    /**
     * Executes the given SQL statement, which may return multiple results, and signals the driver that the
     * auto-generated keys indicated in the given array should be made available for retrieval. This array contains the
     * names of the columns in the target table that contain the auto-generated keys that should be made available.  The
     * driver will ignore the array if the SQL statement is not an <code>INSERT</code> statement, or an SQL statement
     * able to return auto-generated keys (the list of such statements is vendor-specific).
     * <p>
     * In some (uncommon) situations, a single SQL statement may return multiple result sets and/or update counts.
     * Normally you can ignore this unless you are (1) executing a stored procedure that you know may return multiple
     * results or (2) you are dynamically executing an unknown SQL string.
     * <p>
     * The <code>execute</code> method executes an SQL statement and indicates the form of the first result.  You must
     * then use the methods
     * <code>getResultSet</code> or <code>getUpdateCount</code>
     * to retrieve the result, and <code>getMoreResults</code> to move to any subsequent result(s).
     * <p>
     * <strong>Note:</strong>This method cannot be called on a
     * <code>PreparedStatement</code> or <code>CallableStatement</code>.
     *
     * @param sql         any SQL statement
     * @param columnNames an array of the names of the columns in the inserted row that should be made available for
     *                    retrieval by a call to the method <code>getGeneratedKeys</code>
     * @return <code>true</code> if the next result is a <code>ResultSet</code>
     * object; <code>false</code> if it is an update count or there are no more results
     * @throws SQLException                    if a database access error occurs, this method is called on a closed
     *                                         <code>Statement</code>,the elements of the <code>String</code> array
     *                                         passed to this method are not valid column names, the method is called on
     *                                         a
     *                                         <code>PreparedStatement</code> or <code>CallableStatement</code>
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     * @throws SQLTimeoutException             when the driver has determined that the timeout value that was specified
     *                                         by the {@code setQueryTimeout} method has been exceeded and has at least
     *                                         attempted to cancel the currently running {@code Statement}
     * @see #getResultSet
     * @see #getUpdateCount
     * @see #getMoreResults
     * @see #getGeneratedKeys
     */

    public boolean execute(String sql, String[] columnNames) throws SQLException {
        return getPreparedStatement().execute(sql, columnNames);
    }

    /**
     * Retrieves the result set holdability for <code>ResultSet</code> objects generated by this <code>Statement</code>
     * object.
     *
     * @return either <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or
     * <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>
     * @throws SQLException if a database access error occurs or this method is called on a closed
     *                      <code>Statement</code>
     */
    public int getResultSetHoldability() throws SQLException {
        return getPreparedStatement().getResultSetHoldability();
    }

    /**
     * Retrieves whether this object has been closed.
     *
     * @return true if this object is closed; false if it is still open
     */
    public boolean isClosed() {
        return closed;
    }

    /**
     * Returns a  value indicating whether the <code>Statement</code> is poolable or not.
     * <p>
     *
     * @return <code>true</code> if the <code>Statement</code>
     * is poolable; <code>false</code> otherwise
     * <p>
     * @throws SQLException if this method is called on a closed
     *                      <code>Statement</code>
     *                      <p>
     * @see Statement#setPoolable(boolean) setPoolable(boolean)
     * <p>
     */
    public boolean isPoolable() throws SQLException {
        return getPreparedStatement().isPoolable();
    }

    /**
     * Requests that a <code>Statement</code> be pooled or not pooled.  The value specified is a hint to the statement
     * pool implementation indicating whether the application wants the statement to be pooled.  It is up to the
     * statement pool manager as to whether the hint is used.
     * <p>
     * The poolable value of a statement is applicable to both internal statement caches implemented by the driver and
     * external statement caches implemented by application servers and other applications.
     * <p>
     * By default, a <code>Statement</code> is not poolable when created, and a <code>PreparedStatement</code> and
     * <code>CallableStatement</code> are poolable when created.
     * <p>
     *
     * @param poolable requests that the statement be pooled if true and that the statement not be pooled if false
     *                 <p>
     * @throws SQLException if this method is called on a closed
     *                      <code>Statement</code>
     *                      <p>
     */
    public void setPoolable(boolean poolable) throws SQLException {
        //TODO finish this
    }

    private BitSet computeParametersSignature() {
        BitSet bitSet = new BitSet(valueMap.size());
        int i = 0;
        for (Map.Entry<String, Object> entry : valueMap.entrySet()) {
            if (entry.getValue() != null) {
                bitSet.set(i);
            }
            i += 1;
        }
        return bitSet;
    }

    private <T> void changeWithCheckedName(String parameterName, T value, BiSqlConsumer<String, T> setter) throws SQLException {
        ensureNotClosed();
        if (valueMap.containsKey(parameterName)) {
            changeCount++;
            setter.accept(parameterName, value);
        } else {
            throwForUnknownParameter(parameterName);
        }
    }

    private <T, U> void changeWithCheckedName(String parameterName, T value, U value2, TriSqlConsumer<String, T, U> setter) throws SQLException {
        ensureNotClosed();
        if (valueMap.containsKey(parameterName)) {
            changeCount++;
            setter.accept(parameterName, value, value2);
        } else {
            throwForUnknownParameter(parameterName);
        }
    }

    private <T, U, V> void changeWithCheckedName(String parameterName, T value, U value2, V value3, QuadSqlConsumer<String, T, U, V> setter) throws SQLException {
        ensureNotClosed();
        if (valueMap.containsKey(parameterName)) {
            changeCount++;
            setter.accept(parameterName, value, value2, value3);
        } else {
            throwForUnknownParameter(parameterName);
        }
    }

    private void ensureNotClosed() throws SQLException {
        if (closed) {
            throw new SQLException("Unable to modify a " + this.getClass().getSimpleName() + " after it is closed.");
        }
    }

    private void throwForUnknownParameter(String parameterName) throws SQLException {
        throw new SQLException("\"" + parameterName + "\" is not the name of a variable in " + template.getTemplateString());
    }

    /**
     * Get a prepared statement that is configured with the SQL that is an expansion of this object's SmileyVars
     * template based on the parameters that are or are not set.  If this is the first time this prepared statement is
     * being used, all the of previously provided parameter values and configuration values (concurrency, holdability,
     * maxRows, ...) will be set during this method call.
     * <p>Prepared statement objects are reused if the set of parameter values that have and do not have values is the
     * same as the last time the prepared statement was used. If any parameter or configuration values have changed
     * since the last time that the prepared statement was used, this method call will update the prepared statement
     * with those changes.
     * </p>
     *
     * @return a prepared statement that will be configured based the the SmileyVars template that this object was
     * created with and any parameter or configuration values that have been specified since this object's creation.
     */
    public PreparedStatement getPreparedStatement() {
        BitSet signature = computeParametersSignature();
        PreparedStatementTag ptag = taggedPstmtMap.get(signature);
        if (ptag == null) {
            //TODO Finish this
            throw new UnsupportedOperationException();
        }
        if (ptag.getChangeCount() != changeCount) {
            updatePreparedStatement(ptag.getPreparedStatement());
            ptag.setChangeCount(changeCount);
        }
        return ptag.getPreparedStatement();
    }

    @SuppressWarnings("unused")
    private void updatePreparedStatement(PreparedStatement preparedStatement) {
        //TODO finish this
        throw new UnsupportedOperationException();
    }

    /**
     * Tag PreparedStatement objects with a signature so that we can reuse prepared statement objects with different
     * parameter settings.
     */
    private static class PreparedStatementTag {
        private final BitSet signature;
        private final PreparedStatement preparedStatement;
        private long changeCount;

        PreparedStatementTag(BitSet signature, PreparedStatement preparedStatement, long changeCount) {
            this.signature = signature;
            this.preparedStatement = preparedStatement;
            this.changeCount = changeCount;
        }

        BitSet getSignature() {
            return signature;
        }

        PreparedStatement getPreparedStatement() {
            return preparedStatement;
        }

        long getChangeCount() {
            return changeCount;
        }

        void setChangeCount(long changeCount) {
            this.changeCount = changeCount;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            PreparedStatementTag that = (PreparedStatementTag) o;
            return signature.equals(that.signature);
        }

        @Override
        public int hashCode() {
            return signature.hashCode();
        }
    }
}
